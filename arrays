"""
=========================================
DSA - ARRAYS + TIME COMPLEXITY + BIG-O
(Beginner-Friendly Complete Guide)
=========================================

-------------------------------
WHAT IS AN ARRAY?
-------------------------------

An array is a data structure used to store multiple values in a single variable.

In Python, we use a list as an array.

Example:
my_array = [7, 12, 9, 4, 11]

-------------------------------
ARRAY INDEXING
-------------------------------

Each element has an index (position).
Python uses ZERO-BASED indexing.

Index:   0   1   2   3   4
Value:   7  12   9   4  11

my_array[0] → 7
my_array[3] → 4

-----------------------------------------
WHY ARRAYS ARE IMPORTANT
-----------------------------------------

- Store multiple values together
- Easy to access using index
- Used in almost all programs
- Foundation for other data structures

-----------------------------------------
COMMON ARRAY OPERATIONS
-----------------------------------------

Access   → arr[i]
Traversal → Loop through array
Searching → Find a value
Insertion → Add a value
Deletion → Remove a value

-----------------------------------------
ARRAY TIME COMPLEXITIES
-----------------------------------------

Access      → O(1)
Traversal   → O(n)
Searching   → O(n)
Insertion   → O(n)
Deletion    → O(n)

-----------------------------------------
EXAMPLE ARRAY
-----------------------------------------
"""

# =========================================
# 1️⃣ CREATING AND PRINTING AN ARRAY
# =========================================

my_array = [7, 12, 9, 4, 11]
print("Original array:", my_array)


# =========================================
# 2️⃣ ACCESSING ELEMENTS
# =========================================

print("First element:", my_array[0])   # O(1)
print("Fourth element:", my_array[3])  # O(1)


# =========================================
# 3️⃣ TRAVERSING THE ARRAY
# =========================================

print("Traversing the array:")
for i in my_array:
    print(i)  # O(n)


# =========================================
# 4️⃣ SEARCHING IN ARRAY
# =========================================

search_value = 9
found = False

for i in my_array:
    if i == search_value:
        found = True
        break

print("Is 9 in array?", found)  # O(n)


# =========================================
# 5️⃣ INSERTION IN ARRAY
# =========================================

my_array.insert(2, 99)  # Insert at index 2
print("After insertion:", my_array)  # O(n)


# =========================================
# 6️⃣ DELETION FROM ARRAY
# =========================================

my_array.pop(3)  # Remove element at index 3
print("After deletion:", my_array)  # O(n)


# =========================================
# 7️⃣ ALGORITHM: FIND THE LOWEST VALUE
# =========================================

"""
PSEUDOCODE:

1. Set minVal = first element of the array
2. Loop through each element in the array
3. If current element < minVal, update minVal
4. After loop ends, minVal contains the lowest value
"""

minVal = my_array[0]

for i in my_array:
    if i < minVal:
        minVal = i

print("Lowest value:", minVal)  # O(n)


# =========================================
# 8️⃣ TIME COMPLEXITY & BIG-O NOTATION
# =========================================

"""
Time Complexity tells us how the running time of an algorithm grows
as the input size (n) increases.

It does NOT measure time in seconds.
It measures how the number of operations increases.

-----------------------------------------
WHAT IS BIG-O NOTATION?
-----------------------------------------

Big-O notation represents the worst-case time complexity of an algorithm.

-----------------------------------------
IGNORE THESE IN FORMULAS:
-----------------------------------------

Given a formula:
3n² + 5n + 2

We ignore:
- Constants → 2
- Coefficients → 3, 5
- Smaller terms → 5n

We keep:
- Highest power of n → n²

So:
Time Complexity = O(n²)

-----------------------------------------
COMMON TIME COMPLEXITIES
-----------------------------------------

O(1)     → Constant time
O(log n) → Logarithmic time
O(n)     → Linear time
O(n log n) → Linearithmic time
O(n²)    → Quadratic time
O(n³)    → Cubic time
O(2ⁿ)    → Exponential time
O(n!)    → Factorial time

-----------------------------------------
HOW TO IDENTIFY TIME COMPLEXITY FROM CODE
-----------------------------------------

No loop → O(1)
One loop → O(n)
Two nested loops → O(n²)
Loop that halves input → O(log n)
Recursive with 2 calls → O(2ⁿ)
"""


# =========================================
# 9️⃣ CODE EXAMPLES FOR TIME COMPLEXITY
# =========================================

# O(1) — CONSTANT TIME
print(my_array[0])


# O(n) — LINEAR TIME
for i in my_array:
    print(i)


# O(n²) — QUADRATIC TIME
for i in my_array:
    for j in my_array:
        print(i, j)


# O(log n) — LOGARITHMIC TIME
n = 64
while n > 1:
    print(n)
    n = n // 2


# O(2ⁿ) — EXPONENTIAL TIME
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print("Fibonacci of 5:", fibonacci(5))


# =========================================
# 10️⃣ SUMMARY
# =========================================

"""
- Array is a data structure used to store multiple values.
- Elements are accessed using zero-based indexing.
- Array operations have different time complexities.
- Time complexity applies to both algorithms and data structures.
- Big-O notation helps us choose the most efficient algorithm.
- Always ignore constants and smaller terms.

=========================================
END OF FILE
=========================================
"""